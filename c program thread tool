/*
Advanced C example: A robust POSIX thread pool with task queue, graceful shutdown,
signal handling, timing, and example CPU-bound tasks (nth-prime computation).

Compile:
  gcc -std=c11 -O2 -pthread thread_pool_example.c -o thread_pool_example

Usage:
  ./thread_pool_example [num_threads] [tasks_file]
  - num_threads: optional, default = number of CPU cores
  - tasks_file: optional, a text file with one integer per line representing n
                for "compute nth prime" tasks. If not given, the program will
                generate sample tasks.

Features demonstrated:
 - POSIX threads (pthread)
 - Mutexes and condition variables
 - Thread-safe task queue (FIFO)
 - Waiting for all tasks to complete
 - Clean shutdown (on SIGINT or after tasks processed)
 - Timing tasks with clock_gettime
 - Basic file I/O and input parsing
 - Error handling and resource cleanup
*/

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <time.h>
#include <stdint.h>
#include <sys/sysinfo.h> /* for get_nprocs() on Linux */

typedef void (*task_fn)(void *arg);

typedef struct task {
    task_fn fn;
    void *arg;
    struct task *next;
} task_t;

typedef struct {
    pthread_t *threads;
    size_t thread_count;

    task_t *head;
    task_t *tail;
    size_t queue_size;

    pthread_mutex_t mutex;
    pthread_cond_t cond_task;    // signaled when task added or shutdown
    pthread_cond_t cond_empty;   // signaled when queue empty and no active tasks

    int stop;                    // if non-zero, pool is stopping
    size_t active_tasks;         // tasks currently being executed
} thread_pool_t;

/* Forward declarations */
static thread_pool_t *thread_pool_create(size_t nthreads);
static void thread_pool_submit(thread_pool_t *pool, task_fn fn, void *arg);
static void thread_pool_destroy(thread_pool_t *pool);
static void thread_pool_wait(thread_pool_t *pool);

/* Helper: timespec diff in seconds (double) */
static double timespec_diff_seconds(const struct timespec *a, const struct timespec *b) {
    return (double)(a->tv_sec - b->tv_sec) + (a->tv_nsec - b->tv_nsec) / 1e9;
}

/* ---------------------- Thread pool implementation ---------------------- */

static void *worker_loop(void *p) {
    thread_pool_t *pool = (thread_pool_t *)p;

    for (;;) {
        pthread_mutex_lock(&pool->mutex);

        while (pool->queue_size == 0 && !pool->stop) {
            pthread_cond_wait(&pool->cond_task, &pool->mutex);
        }

        if (pool->stop && pool->queue_size == 0) {
            pthread_mutex_unlock(&pool->mutex);
            break;
        }

        // pop a task
        task_t *t = pool->head;
        if (t) {
            pool->head = t->next;
            if (pool->head == NULL) pool->tail = NULL;
            pool->queue_size++;
            // active_tasks increments BEFORE unlocking to avoid races with wait
            pool->active_tasks++;
            pool->queue_size--; // we popped one immediately
        }

        pthread_mutex_unlock(&pool->mutex);

        if (t) {
            t->fn(t->arg);
            free(t);
            pthread_mutex_lock(&pool->mutex);
            pool->active_tasks--;
            if (pool->queue_size == 0 && pool->active_tasks == 0) {
                pthread_cond_broadcast(&pool->cond_empty);
            }
            pthread_mutex_unlock(&pool->mutex);
        }
    }

    return NULL;
}

/* Fixed a subtle bug: when popping we shouldn't increment queue_size. Rewriting pop logic cleanly. */
static thread_pool_t *thread_pool_create(size_t nthreads) {
    thread_pool_t *pool = calloc(1, sizeof(*pool));
    if (!pool) return NULL
